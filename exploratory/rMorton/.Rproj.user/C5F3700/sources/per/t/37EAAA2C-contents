---
title: "Source Cred EDA"
author: "Ryan Morton, Morton Analytics"
date: "April 9, 2019"
output: 
  html_document:
    toc: true
    toc_float: true
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(jsonlite)
library(rvest)
library(xml2)
library(tidyr)
library(dplyr)
library(purrr)
library(tidytext)
library(myIO)
library(DT)
library(shiny)
library(shinydashboard)

df <- read_html("https://raw.githubusercontent.com/sourcecred/research/master/sample-graphs/sourcecred_sourcecred.json") %>%
  html_node('body') %>%
  html_text() %>%
  fromJSON()

df_nodes <- map_df(df$nodes[[2]] , function(x) {
  if(length(x) == 4){
    node_type <- gsub("_$", "", paste0(x[1:3], collapse = "_"))
    final <- data.frame(node_type = node_type, stringsAsFactors = FALSE)
  } else {
    node_type <- gsub("_$", "", paste0(x[1:4], collapse = "_"))
    final <- data.frame(node_type = node_type, stringsAsFactors = FALSE)
  }
  
  return(final)
})

df_edges <- df$edges[[2]] %>%
  bind_cols() %>%
  group_by(row_number()) %>%
  mutate(edge_type = gsub("_$", "", paste0(gsub("[0-9]", "", address[1][[1]][1:4]), collapse = "_")),
         source_node = df_nodes$node_type[ srcIndex + 1 ],
         dest_node = df_nodes$node_type[ dstIndex + 1 ]) %>%
  ungroup()%>%
  select(edge_type, srcIndex, dstIndex, source_node, dest_node)

## count node types
node_types_count <- df_nodes %>%
  group_by(node_type) %>%
  summarise(Counts = as.numeric(n())) %>%
  arrange(Counts)

node_types_graph <- myIO::myIO(width = "100%") %>%
  myIO::addIoLayer(type = "bar",
             color = "steelblue",
             label = "Count",
             data = node_types_count,
             mapping = list(
               x_var = 'node_type',
               y_var = "Counts"
             ),
             options = list(barSize = "large"))%>%
  myIO::setAxisLimits(ylim = list(min = "0")) %>%
  myIO::setAxisFormat(xAxis = "text",yAxis = ",.0f", toolTip = ",.0f") %>%
  myIO::flipAxis()%>%
  myIO::defineCategoricalAxis()%>%
  myIO::setmargin(left = 250, top = 40)%>%
  myIO::suppressLegend()

## count edge types
edge_types_count <- df_edges %>%
  group_by(edge_type) %>%
  summarise(Counts = as.numeric(n())) %>%
  arrange(Counts)

edge_types_graph <- myIO::myIO(width = "100%") %>%
  myIO::addIoLayer(type = "bar",
                   color = "orange",
                   label = "Count",
                   data = edge_types_count,
                   mapping = list(
                     x_var = 'edge_type',
                     y_var = "Counts"
                   ),
                   options = list(barSize = "large"))%>%
  myIO::setAxisLimits(ylim = list(min = "0")) %>%
  myIO::setAxisFormat(xAxis = "text",yAxis = ",.0f", toolTip = ",.0f") %>%
  myIO::flipAxis()%>%
  myIO::defineCategoricalAxis()%>%
  myIO::setmargin(left = 250, top = 40)%>%
  myIO::suppressLegend()

## count node pairings (by edge type?)
node_pairings_count <- df_edges %>%
  group_by(edge_type, source_node, dest_node) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

node_pairings_table <- DT::datatable(node_pairings_count)

## text analysis of nodes
node_tokens <- df$nodes[[2]] %>%
  lapply(., function(x){
    final = data.frame(text = paste0(x, collapse = ", "), stringsAsFactors = FALSE)
    return(final)
  }) %>% 
  bind_rows() %>%
  unnest_tokens(word, text) %>%
  filter(!grepl("[0-9]", word)) %>%
  group_by(word) %>%
  summarise(Count = n()) %>%
  top_n(10, Count) %>%
  arrange(Count)

node_tokens_graph <- myIO::myIO(width = "100%") %>%
  myIO::addIoLayer(type = "bar",
                   color = "#004D40",
                   label = "Count",
                   data = node_tokens,
                   mapping = list(
                     x_var = 'word',
                     y_var = "Count"
                   ),
                   options = list(barSize = "large"))%>%
  myIO::setAxisLimits(ylim = list(min = "0")) %>%
  myIO::setAxisFormat(xAxis = "text",yAxis = ",.0f", toolTip = ",.0f") %>%
  myIO::flipAxis()%>%
  myIO::defineCategoricalAxis()%>%
  myIO::setmargin(left = 100, top = 40)%>%
  myIO::suppressLegend()

## text analysis of edges
edge_tokens <- df$edges[[2]]$address %>%
  lapply(., function(x){
     final = data.frame(text = paste0(x, collapse = ", "), stringsAsFactors = FALSE)
     return(final)
  }) %>% 
  bind_rows() %>%
  unnest_tokens(word, text) %>%
  filter(!grepl("[0-9]", word)) %>%
  group_by(word) %>%
  summarise(Count = n())%>%
  top_n(20, Count) %>%
  arrange(Count)

edge_tokens_graph <- myIO::myIO(width = "100%") %>%
  myIO::addIoLayer(type = "bar",
                   color = "#D81B60",
                   label = "Count",
                   data = edge_tokens,
                   mapping = list(
                     x_var = 'word',
                     y_var = "Count"
                   ),
                   options = list(barSize = "large"))%>%
  myIO::setAxisLimits(ylim = list(min = "0")) %>%
  myIO::setAxisFormat(xAxis = "text",yAxis = ",.0f", toolTip = ",.0f") %>%
  myIO::flipAxis()%>%
  myIO::defineCategoricalAxis()%>%
  myIO::setmargin(left = 150, top = 40)%>%
  myIO::suppressLegend()

```

## Introduction

This document presents an exploratory data analysis of the Source Cred graph data located at GitHub. This analysis exists an RMarkdown file that can be rerun on demand given new data available.

The data holds `r format(nrow(df_nodes), big.mark = ",")` nodes and `r format(nrow(df_edges), big.mark = ",")` edges. For the different node and edge types, there are `r format(nrow(node_pairings_count), big.mark = ",")` unique node pairings.

## Node Types

Nodes are stored as an array of strings following this basic pattern:

```{r eval=FALSE, echo=TRUE}
{"sourcecred","git","COMMIT","007cf88172d7ea9b0cdada78f124f7a41b811b30"}
```

To determine the node types, the first 3-4 string objects in the node were concatenated. This yielded `r format(nrow(node_types_count), big.mark = ",")` unique node types summarized by counts in the graph below.

```{r}
shiny::fluidRow(shiny::column(12, (shinydashboard::box(node_types_graph, width = "90%"))))
```

## Edge Types

Edges are stored as a nested array with an address and two index numbers relating to the connected nodes. The address nests the data relating to the edge type. An example of an edge looks like (commit hashes have been truncated for reading ease):

```{r eval=FALSE, echo=TRUE}
{
  "address": [
    "sourcecred", "git","HAS_PARENT", "2","COMMIT","007cf881...",  "2","COMMIT","d310561b..."
    ],
  "dstIndex": 744,
  "srcIndex": 0
}
```

To determine the edge types, the first 3-4 string objects in the node were concatenated. This yielded `r format(nrow(edge_types_count), big.mark = ",")` unique edge types summarized by counts in the graph below.

```{r}
shiny::fluidRow(shiny::column(12, (shinydashboard::box(edge_types_graph, width = "90%"))))
```

## Node Pairings

To get a better sense of how nodes and egdes work together to form the network, we can look at the node pairings by edge type. Currently, there are `r format(nrow(node_pairings_count), big.mark = ",")` pairings summarized by counts in the table below.

```{r}
node_pairings_table
```

## Node Word Tokens

While the node types appear to clearly identify all the important information about nodes, a text based analysis was employed to confirm that node types are the predominant data stored in the nodes. The text analysis tokenized the words in the node data and generated word counts across all nodes. The top `r format(nrow(node_tokens), big.mark = ",")` words are are summarized in the chart below.

```{r}
shiny::fluidRow(shiny::column(12, (shinydashboard::box(node_tokens_graph, width = "90%"))))
```

## Edge Word Tokens

While the edge types appear to clearly identify all the important information about edges, a text based analysis was employed to confirm that edge types are the predominant data stored in the edges. In addition, user names begin to show up more dominantly in edges than in nodes. 

The text analysis tokenized the words in the edge data and generated word counts across all edges. The top `r format(nrow(edge_tokens), big.mark = ",")` words are are summarized in the chart below.

```{r}
shiny::fluidRow(shiny::column(12, (shinydashboard::box(edge_tokens_graph, width = "90%"))))
```

## Recommendations

Given the data available, the following recommendations are made for visualizing the data:

- Node and Edge Types provide a stable view of the data that can easily translate to a data visualization

- Edge data provides greater information regarding the who and what of the network graph

- Adding node and edge scoring would improve the understanding of the network

- Labelling would require a subset of data as the current data set is too large

- Data visualizations should include at least the option for the following elements:
  
    1. Node types by color
  
    2. Edge types by color
  
    3. Node scores/weights by radius size
  
    4. Edge scores/weights by stroke width
  
    5. Popover capabilities for displaying more in-depth information and labels
  
    6. Data management support for unnamed and nested node/edge data